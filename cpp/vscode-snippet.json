{
	"fenwick-tree": {
		"prefix": "fenwick",
		"body": [
			"namespace cp_template {",
			"  #include <vector>",
			"  #define lowbit(x) ((x)&(-x))",
			"",
			"  // 1-base",
			"  template<class T, class trait> class fenwick_tree {",
			"    int size;",
			"    std::vector<T> bit;",
			"    trait op;",
			"",
			"    public:",
			"    fenwick_tree(int _size) : size(_size + 1), op(trait()) {",
			"      bit.resize(size, T());",
			"    }",
			"    void build(const std::vector<T>& arr) {",
			"      assert(arr.size() == bit.size() - 1);",
			"      for(int i = 1; i < size; ++i)",
			"        bit[i] = arr[i - 1];",
			"      for(int i = 1; i < size; ++i) {",
			"        int j = i + lowbit(i);",
			"        if(j < size)",
			"          bit[j] = op.merge(bit[j], bit[i]);",
			"      }",
			"    }",
			"    void upd(int x, T v) {",
			"      assert(1 <= x && x < size);",
			"      for(; x < size; x += lowbit(x))",
			"        bit[x] = op.merge(bit[x], v);",
			"    }",
			"    T sum(int x) {",
			"      assert(0 <= x && x < size);",
			"      T ret = 0;",
			"      for(; x; x -= lowbit(x))",
			"        ret = op.merge(ret, bit[x]);",
			"      return ret;",
			"    }",
			"    T qry(int l, int r) { //[l, r]",
			"      --l;",
			"      assert(l <= r);",
			"      return op.sub(sum(l), sum(r));",
			"    }",
			"  };",
			"  #undef lowbit",
			"",
			"  namespace trait {",
			"    template<class T> struct fenwick_tree_op {",
			"      // merge(l, r)",
			"      // merge values of [l] and [r] or bit array and update value",
			"      virtual T merge(const T&, const T&) = 0;",
			"",
			"      // sub(l, r)",
			"      // subtract values of [1, l) and [1, r] => become [l, r]",
			"      virtual T sub(const T&, const T&) = 0;",
			"    };",
			"",
			"    template<class T> struct fenwick_tree_add : public fenwick_tree_op<T> {",
			"      T merge(const T& l, const T& r) { return l + r; }",
			"      T sub(const T& l, const T& r) { return r - l; };",
			"    };",
			"    template<class T> struct fenwick_tree_xor : public fenwick_tree_op<T> {",
			"      T merge(const T& l, const T& r) { return l ^ r; }",
			"      T sub(const T& l, const T& r) { return r ^ l; };",
			"    };",
			"  }",
			"}"
		],
		"description": "fenwick-tree"
	},
	"segment-tree": {
		"prefix": "segment",
		"body": [
			"namespace cp_template {",
			"  #include <vector>",
			"  #include <limits>",
			"  #define mid ((l + r) / 2)",
			"  #define lc (id << 1)",
			"  #define rc (id << 1 | 1)",
			"",
			"  template<class T, class trait, class Tt = T> class segment_tree {",
			"    protected:",
			"    int size, rb, check;",
			"    T nan;",
			"    Tt clear_tag;",
			"    std::vector<T> seg;",
			"    std::vector<Tt> tag;",
			"    trait op;",
			"",
			"    void push(int id, int l, int r) {",
			"      if(op.empty(tag[id])) return;",
			"      seg[id] = op.upd(seg[id], tag[id], l, r);",
			"      if(l != r) {",
			"        tag[lc] = op.push(tag[lc], tag[id]);",
			"        tag[rc] = op.push(tag[rc], tag[id]);",
			"      }",
			"      tag[id] = clear_tag;",
			"    }",
			"    void build(const std::vector<T>& arr, int id, int l, int r) {",
			"      if(l == r) {",
			"        seg[id] = arr[l - 1];",
			"        return;",
			"      }",
			"      build(arr, lc, l, mid), build(arr, rc, mid + 1, r);",
			"      seg[id] = op.merge(seg[lc], seg[rc]);",
			"    }",
			"    void upd(int id, int l, int r, int ql, int qr, const Tt& v) {",
			"      push(id, l, r);",
			"      if(r < ql || l > qr) return;",
			"      if(ql <= l && r <= qr) {",
			"        tag[id] = op.push(tag[id], v);",
			"        push(id, l, r);",
			"        return;",
			"      }",
			"      upd(lc, l, mid, ql, qr, v), upd(rc, mid + 1, r, ql, qr, v);",
			"      seg[id] = op.merge(seg[lc], seg[rc]);",
			"    }",
			"    T qry(int id, int l, int r, int ql, int qr) {",
			"      push(id, l, r);",
			"      if(r < ql || l > qr) return nan;",
			"      if(ql <= l && r <= qr) return seg[id];",
			"      return op.merge(qry(lc, l, mid, ql, qr), qry(rc, mid + 1, r, ql, qr));",
			"    }",
			"",
			"    public:",
			"    segment_tree(int _size) : rb(_size), size(_size << 2 | 1), op(trait()), nan(op.nan()), check(op.check()), clear_tag(op.clear_tag()) {",
			"      seg.resize(size, T());",
			"      tag.resize(size, clear_tag);",
			"    }",
			"    void build(const std::vector<T>& arr) {",
			"      assert(arr.size() == (size >> 2));",
			"      build(arr, 1, 1, rb);",
			"    }",
			"    void upd(int x, Tt v) {",
			"      assert(1 <= x && x <= rb && check == 0);",
			"      upd(1, 1, rb, x, x, v);",
			"    }",
			"    void upd(int ql, int qr, Tt v) {",
			"      assert(1 <= ql && ql <= qr && qr <= rb && check == 1);",
			"      upd(1, 1, rb, ql, qr, v);",
			"    }",
			"    T qry(int ql, int qr) {",
			"      assert(1 <= ql && ql <= qr && qr <= rb);",
			"      return qry(1, 1, rb, ql, qr);",
			"    }",
			"  };",
			"  #undef mid",
			"  #undef lc",
			"  #undef rc",
			"",
			"  namespace trait {",
			"    template<class T, class Tt = T> struct segment_tree_op {",
			"      // check()",
			"      // return segment tree update method",
			"      // 0 -> single update",
			"      // 1 -> range update",
			"      virtual int check() = 0;",
			"",
			"      // nan()",
			"      // return out of boundary value",
			"      virtual T nan() = 0;",
			"",
			"      // merge(l, r)",
			"      // merge values of [l] and [r]",
			"      virtual T merge(T, T) = 0;",
			"",
			"      // upd(seg, tag, l, r)",
			"      // update seg value by tag value and interval [l, r]",
			"      virtual T upd(T seg, Tt tag, int l, int r) = 0;",
			"",
			"      // push(current_tag, parent_tag)",
			"      // update current tag value by parent tag value",
			"      virtual Tt push(Tt, Tt) = 0;",
			"",
			"      // empty(tag)",
			"      // has default methed",
			"      // true if need to update value and push down lazy tag",
			"      virtual bool empty(Tt t) { return t == Tt(); }",
			"",
			"      // clear_tag()",
			"      // has default value",
			"      // return cleared tag value",
			"      virtual Tt clear_tag() { return Tt(); }",
			"    };",
			"  }",
			"}"
		],
		"description": "segment-tree"
	},
	"modular": {
		"prefix": "modular",
		"body": [
			"namespace cp_template {",
			"  template<class T, T M> class modular {",
			"    T value;",
			"",
			"    public:",
			"    modular(T val=T()) {",
			"      value = val;",
			"      value %= M; if(value < 0) value += M;",
			"    }",
			"    template<class P> modular(P val) {",
			"      value = val;",
			"      value %= M; if(value < 0) value += M;",
			"    }",
			"    ",
			"    T pow(T a, T b) {",
			"      T ret=1;",
			"      for(a%=M; b; b>>=1, a=a*a%M) if(b&1) ret=ret*a%M;",
			"      return ret;",
			"    }",
			"    modular pow(T p) {return pow(value, p);}",
			"    modular operator+(modular m) {return modular(value+m.value);}",
			"    modular operator-(modular m) {return modular(value-m.value);}",
			"    modular operator*(modular m) {return modular(value*m.value);}",
			"    modular operator/(modular m) {return modular(value*pow(m.value, M-2));} // works if M is prime",
			"    modular operator+=(modular m) {*this=operator+(m); return *this;}",
			"    modular operator-=(modular m) {*this=operator-(m); return *this;}",
			"    modular operator*=(modular m) {*this=operator*(m); return *this;}",
			"    modular operator/=(modular m) {*this=operator/(m); return *this;}",
			"    modular operator++() {*this=operator+(1); return *this;}",
			"    modular operator++(int) {modular r=*this; operator++(); return r;}",
			"    modular operator--() {*this=operator-(1); return *this;}",
			"    modular operator--(int) {modular r=*this; operator--(); return r;}",
			"    template<class P> friend modular operator-(P v, modular m) {return modular(v-m.value);}",
			"    template<class P> friend modular operator/(P v, modular m) {return modular(v)/m;}",
			"    T get() {return value;}",
			"",
			"    bool operator==(modular m) {return value==m.value;}",
			"    bool operator!=(modular m) {return value!=m.value;}",
			"    bool operator<(modular m) {return value<m.value;}",
			"    bool operator>(modular m) {return value>m.value;}",
			"    bool operator<=(modular m) {return value<=m.value;}",
			"    bool operator>=(modular m) {return value>=m.value;}",
			"",
			"    friend istream& operator>>(istream& is, modular& m) {is>>m.value; return is;}",
			"    friend ostream& operator<<(ostream& os, modular m) {os<<m.value; return os;}",
			"  };",
			"}"
		],
		"description": "modular"
	}
}